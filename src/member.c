#include "member.h"
#include "constants.h"
#include "encode.h"
#include "log.h"
#include "message.h"
#include "microswim.h"
#include "ping.h"
#include "update.h"
#include "utils.h"
#include <stdlib.h>

/**
 * @brief Returns a pointer to the next member in a round-robin sequence.
 *
 * Retrieves the next member from the array of members round-robin manner.
 * The array is iterated in order, and each member is accessed sequentially.
 *
 * If the array is empty, the function returns NULL. If the round-robin
 * index reaches the end of the current array, the members are reordered
 * randomly before continuing the round-robin sequence.
 *
 * @return A pointer to the next member, or NULL if the array is empty.
 */
microswim_member_t* microswim_member_retrieve(microswim_t* ms) {
    if (ms->member_count == 0) {
        return NULL;
    }

    int original_index = ms->round_robin_index;

    while (1) {
        // NOTE: we do not care whether the member is ALIVE or SUSPECT.
        // As long as it is not CONFIRMED, we can send it a ping message.
        size_t index = ms->indices[ms->round_robin_index];

        microswim_member_t* member = &ms->members[index];
        ms->round_robin_index = (ms->round_robin_index + 1) % ms->member_count;

        if (ms->round_robin_index == 0) {
            microswim_indices_shuffle(ms);
        }

        if (strncmp((char*)ms->self.uuid, (char*)member->uuid, UUID_SIZE) != 0) {
            return member;
        }

        if (ms->round_robin_index == original_index) {
            // NOTE: No valid member found after iterating through
            // the entire array of members.
            return NULL;
        }
    }
}

/**
 * @brief Adds a member to the central member array.
 *
 * Adds a member to the central member array with all the relevant information,
 * such as the UUID, member's address, incarnation number, status. It also calculates
 * a timeout value at which the node should be declared suspect.
 *
 * @return A pointer to the added member, or NULL if the member cannot be added due to the limit of the array.
 */
microswim_member_t* microswim_member_add(microswim_t* ms, microswim_member_t member) {
    if (ms->member_count > MAXIMUM_MEMBERS) {
        LOG_ERROR("Cannot add more than %d members\n", MAXIMUM_MEMBERS);
        return NULL;
    }

    microswim_member_t* slot = &ms->members[ms->member_count++];
    strncpy((char*)slot->uuid, (char*)member.uuid, UUID_SIZE);
    slot->addr = member.addr;
    slot->incarnation = member.incarnation;
    slot->status = member.incarnation;
    slot->timeout = (microswim_milliseconds() + (uint64_t)(SUSPECT_TIMEOUT * 1000));

    return slot;
}

/**
 * @brief Searches for a member from the central member array.
 *
 * Searches for a member from the central member array. If the member has no UUID, the node will be
 * searched for using its address and if found, its UUID will be updated from the supplied `member`
 * parameter. (it can happen during the launch because initially, we supply only the address and
 * port and the UUID is only generated by the node itself)
 *
 * @return A pointer to the found member, or NULL if the member was not found.
 */
microswim_member_t* microswim_member_find(microswim_t* ms, microswim_member_t* member) {
    for (size_t i = 0; i < ms->member_count; i++) {
        if (ms->members[i].uuid[0] == '\0') {
            int c = microswim_member_address_compare(&ms->members[i], member);
            if (c == (SIN_FAMILY | SIN_PORT | SIN_ADDR)) {
                LOG_DEBUG("Updated member's UUID");
                strncpy((char*)ms->members[i].uuid, (char*)member->uuid, UUID_SIZE);
            }
        }

        if (strncmp((char*)member->uuid, (char*)ms->members[i].uuid, UUID_SIZE) == 0) {
            return &ms->members[i];
        }
    }

    return NULL;
}

/**
 * @brief Searches for a member from the central confirmed member array.
 *
 * @return A pointer to the found member, or NULL if the member was not found.
 */
microswim_member_t* microswim_member_confirmed_find(microswim_t* ms, microswim_member_t* member) {
    for (size_t i = 0; i < ms->confirmed_count; i++) {
        if (strncmp((char*)member->uuid, (char*)ms->confirmed[i].uuid, UUID_SIZE) == 0) {
            return &ms->confirmed[i];
        }
    }

    return NULL;
}

/**
 * @brief Shifts the central member array.
 *
 * Shifts the central member array after the member is moved to the confirmed member array.
 * Additionally, the member's pointer in the central updates array is updated as well.
 */
void microswim_members_shift(microswim_t* ms, size_t index) {
    for (size_t i = index; i < ms->member_count - 1; i++) {
        microswim_update_t* update = microswim_update_find(ms, &ms->members[i + 1]);
        ms->members[i] = ms->members[i + 1];
        if (update != NULL) {
            update->member = &ms->members[i];
        }
    }

    ms->member_count--;
}

/**
 * @brief Updates the member.
 */
void microswim_member_update(microswim_t* ms, microswim_member_t* ex, microswim_member_t* nw) {
    // NOTE: this should probably move somewhere else.
    if (strncmp((char*)ms->self.uuid, (char*)nw->uuid, UUID_SIZE) == 0 && (nw->status == SUSPECT)) {
        // TODO: check all the ms->self references.
        ms->self.incarnation = nw->incarnation + 1;
        ms->self.status = ALIVE;
        ex->incarnation = nw->incarnation + 1;
        ex->status = ALIVE;

        microswim_message_t message = { 0 };
        microswim_status_message_construct(ms, &message, ALIVE_MESSAGE, ex);
        microswim_member_t* recipient = microswim_member_retrieve(ms);
        if (recipient != NULL) {
            unsigned char buffer[BUFFER_SIZE] = { 0 };
            size_t length = microswim_encode_message(&message, buffer, BUFFER_SIZE);
            microswim_message_send(ms, recipient, (const char*)buffer, length);
        }

        return;
    }

    if (nw->status == ALIVE) {
        // {Alive M1, inc = i} overrides:
        // - {Suspect M1, inc = j} if i > j
        // - {Alive M1, inc = j} if i > j
        if ((ex->status == SUSPECT && nw->incarnation > ex->incarnation) ||
            (ex->status == ALIVE && nw->incarnation > ex->incarnation)) {
            ex->status = nw->status;
            ex->incarnation = nw->incarnation;
            ex->timeout = (microswim_milliseconds() + (uint64_t)(SUSPECT_TIMEOUT * 1000));

            microswim_member_t member = { 0 };
            strncpy((char*)member.uuid, (char*)ex->uuid, UUID_SIZE);
            microswim_ping_t* ping = microswim_ping_find(ms, &member);
            if (ping != NULL) {
                microswim_ping_remove(ms, ping);
            }
        }
    }

    if (nw->status == SUSPECT) {
        // {Suspect M1, inc = i} overrides:
        // - {Suspect M1, inc = j} if i > j
        // - {Alive M1, inc = j} if i >= j
        if ((ex->status == SUSPECT && nw->incarnation > ex->incarnation) ||
            (ex->status == ALIVE && nw->incarnation >= ex->incarnation)) {
            ex->status = nw->status;
            ex->incarnation = nw->incarnation;
            ex->timeout = (microswim_milliseconds() + (uint64_t)(SUSPECT_TIMEOUT * 1000));

            microswim_member_t member = { 0 };
            strncpy((char*)member.uuid, (char*)ex->uuid, UUID_SIZE);
            microswim_ping_t* ping = microswim_ping_find(ms, &member);
            if (ping != NULL) {
                microswim_ping_remove(ms, ping);
            }
        }
    }

    if (nw->status == CONFIRMED) {
        // {Confirm M1, inc = i} overrides:
        // - {Alive M1, inc = j} for any j
        // - {Suspect M1, inc = j} for any j
        if (ex->status == ALIVE || ex->status == SUSPECT) {
            ex->status = nw->status;
            ex->incarnation = nw->incarnation;

            microswim_member_t member = { 0 };
            strncpy((char*)member.uuid, (char*)ex->uuid, UUID_SIZE);
            microswim_ping_t* ping = microswim_ping_find(ms, &member);
            if (ping != NULL) {
                microswim_ping_remove(ms, ping);
            }

            microswim_member_mark_confirmed(ms, ex);
            microswim_index_remove(ms);
        }
    }
}

/**
 * @brief Moves the member to the confirmed member array.
 *
 * @return A pointer to the moved member or if no member was moved, the functions returns NULL.
 */
microswim_member_t* microswim_member_move(microswim_t* ms, microswim_member_t* member) {
    int index = -1;

    for (int i = 0; i < ms->member_count; i++) {
        if (&ms->members[i] == member) {
            index = i;
            break;
        }
    }

    if (index >= 0) {
        microswim_ping_t* ping = microswim_ping_find(ms, member);
        if (ping != NULL) {
            microswim_ping_remove(ms, ping);
        }

        ms->confirmed[ms->confirmed_count] = ms->members[index];

        microswim_update_t* update = microswim_update_find(ms, &ms->members[index]);
        if (update != NULL) {
            update->member = &ms->confirmed[ms->confirmed_count];
        }

        microswim_members_shift(ms, index);

        return &ms->confirmed[ms->confirmed_count++];
    }

    return NULL;
}

/**
 * @brief Marks the member alive and issues a status message in case the member was marked as suspect.
 */
void microswim_member_mark_alive(microswim_t* ms, microswim_member_t* member) {
    microswim_member_status_t status = member->status;
    member->status = ALIVE;
    member->timeout = (microswim_milliseconds() + (uint64_t)(SUSPECT_TIMEOUT * 1000));
    LOG_DEBUG("Member: %s was marked alive", member->uuid);

    if (status == SUSPECT) {
        microswim_message_t message = { 0 };
        microswim_status_message_construct(ms, &message, ALIVE_MESSAGE, member);

        microswim_member_t* recipient = microswim_member_retrieve(ms);
        if (recipient != NULL) {
            unsigned char buffer[BUFFER_SIZE] = { 0 };
            size_t length = microswim_encode_message(&message, buffer, BUFFER_SIZE);
            microswim_message_send(ms, recipient, (const char*)buffer, length);
        }
    }
}

/**
 * @brief Marks the member as suspect and issues a status message in case the member was marked as alive.
 */
void microswim_member_mark_suspect(microswim_t* ms, microswim_member_t* member) {
    if (member->status == ALIVE) {
        member->status = SUSPECT;
        member->timeout = (microswim_milliseconds() + (uint64_t)(SUSPECT_TIMEOUT * 1000));
        LOG_DEBUG("Member: %s was marked suspect", member->uuid);

        microswim_message_t message = { 0 };
        microswim_status_message_construct(ms, &message, SUSPECT_MESSAGE, member);

        microswim_member_t* recipient = microswim_member_retrieve(ms);
        if (recipient != NULL) {
            unsigned char buffer[BUFFER_SIZE] = { 0 };
            size_t length = microswim_encode_message(&message, buffer, BUFFER_SIZE);
            microswim_message_send(ms, recipient, (const char*)buffer, length);
        }
    }
}

/**
 * @brief Marks the member as confirmed and issues a status message.
 */
void microswim_member_mark_confirmed(microswim_t* ms, microswim_member_t* member) {
    member->status = CONFIRMED;
    LOG_DEBUG("Member: %s was marked confirmed", member->uuid);

    microswim_ping_t* ping = microswim_ping_find(ms, member);
    if (ping != NULL) {
        microswim_ping_remove(ms, ping);
    }

    microswim_member_move(ms, member);

    microswim_message_t message = { 0 };
    microswim_status_message_construct(ms, &message, CONFIRM_MESSAGE, member);

    microswim_member_t* recipient = microswim_member_retrieve(ms);
    if (recipient != NULL) {
        unsigned char buffer[BUFFER_SIZE] = { 0 };
        size_t length = microswim_encode_message(&message, buffer, BUFFER_SIZE);
        microswim_message_send(ms, recipient, (const char*)buffer, length);
    }
}

/**
 * @brief Compares the addresses of two members.
 *
 * @return A mask indicating whether any of the three (SIN_FAMILY, SIN_PORT or SIN_ADDR) match.
 */
size_t microswim_member_address_compare(microswim_member_t* a, microswim_member_t* b) {
    size_t r = 0;

    if (a->addr.sin_family == b->addr.sin_family)
        r |= SIN_FAMILY;
    if (ntohs(a->addr.sin_port) == ntohs(b->addr.sin_port))
        r |= SIN_PORT;
    if (a->addr.sin_addr.s_addr == b->addr.sin_addr.s_addr)
        r |= SIN_ADDR;

    return r;
}

/**
 * @brief Adds a member to the central confirmed member array.
 *
 * @return A pointer to the member added to the confirmed member array.
 */
microswim_member_t* microswim_member_confirmed_add(microswim_t* ms, microswim_member_t member) {
    if (ms->confirmed_count > MAXIMUM_MEMBERS) {
        LOG_ERROR("Cannot add more than %d members\n", MAXIMUM_MEMBERS);
        return NULL;
    }

    microswim_member_t* slot = &ms->confirmed[ms->confirmed_count++];
    strncpy((char*)slot->uuid, (char*)member.uuid, UUID_SIZE);
    slot->addr = member.addr;
    slot->incarnation = member.incarnation;
    slot->status = member.status;
    slot->timeout = 0;

    return slot;
}

/**
 * @brief Retrieves candidate members for the PING_REQ.
 *
 * @return A number of members that will be used for indirect pings.
 */
size_t microswim_get_ping_req_candidates(microswim_t* ms, size_t members[FAILURE_DETECTION_GROUP]) {
    size_t member_count = 0;
    for (size_t i = 0; (i < ms->member_count - 1 && i < FAILURE_DETECTION_GROUP); i++) {
        bool exists = false;
        while (!exists) {
            size_t index = rand() % (ms->member_count - 1) + 1;

            for (size_t j = 0; j <= member_count; j++) {
                if (index == members[j]) {
                    exists = true;
                    break;
                }
            }

            if (!exists) {
                members[member_count++] = index;
                break;
            }

            exists = false;
        }
    }

    return member_count;
}

/**
 * @brief
 */
void microswim_members_check(microswim_t* ms, microswim_member_t* member) {
    microswim_member_t* existing_member = microswim_member_find(ms, member);
    microswim_member_t* confirmed_member = microswim_member_confirmed_find(ms, member);

    if (existing_member == NULL && confirmed_member == NULL) {
        // Member is not found in either list, add it to the appropriate list
        if (member->status == CONFIRMED) {
            LOG_DEBUG("Added member: %s to confirmed list.", member->uuid);
            microswim_member_t* new_member = microswim_member_confirmed_add(ms, *member);
            if (new_member != NULL) {
                microswim_update_add(ms, new_member);
            }
        } else {
            microswim_member_t* new_member = microswim_member_add(ms, *member);
            if (new_member != NULL) {
                microswim_index_add(ms);
                microswim_update_add(ms, new_member);
            }
        }
    } else if (existing_member != NULL) {
        // Member exists in the regular list
        microswim_member_update(ms, existing_member, member);
        if (member->status != CONFIRMED) {
            microswim_update_t* update = microswim_update_find(ms, existing_member);
            if (existing_member->uuid[0] != '\0' && update == NULL) {
                microswim_update_add(ms, existing_member);
            }
        }
    }
}

/**
 * @brief Checks the suspected members and moves to confirmed if the timeout value is exceeded.
 */
void microswim_members_check_suspects(microswim_t* ms) {
    for (size_t i = 0; i < ms->member_count; i++) {
        if (ms->members[i].status == SUSPECT) {
            if (ms->members[i].timeout < microswim_milliseconds()) {
                microswim_member_t* confirmed = microswim_member_confirmed_find(ms, &ms->members[i]);
                // BUG: What should happen if confirmed is found?
                if (!confirmed) {
                    microswim_member_mark_confirmed(ms, &ms->members[i]);
                    microswim_index_remove(ms);
                }
            }
        }
    }
}
